/*
 * Copyright. GaÃ«l Dottel, Christoph Hilken, and Jan Peleska 2016 - 2021
 *
 * Licensed under the EUPL V.1.1
 */
#include "Network.h"
#include "graphs/NetworkEdge.h"

#include <fstream>
#include <iostream>
#include <algorithm>

Network::Network(const vector<shared_ptr<Node>> &nodes,int sourceNodeId, int sinkNodeId)
    : Graph(nodes),sourceNodeId(sourceNodeId),sinkNodeId(sinkNodeId)
{
    residualNetwork = make_shared<Network>(this);
}


Network::Network(Network *network)
    : Graph(vector<shared_ptr<Node>>(network->nodes.size(),nullptr)),sourceNodeId(network->sourceNodeId),
        sinkNodeId(network->sinkNodeId),residualNetwork(shared_ptr<Network>())
{
    /**
     * It is assumed that network itself does not contain any reverse edges and is an actual network and no residual,
     * otherwise the network generated by this constructor, is anything else than a residual network for 'network'.
     */

    for(auto& node:network->nodes) {
        auto& correspondingNode = nodes[node->getId()];
        if(!correspondingNode) {
            correspondingNode = make_shared<Node>(node->getId());
        }
        int edgesSize = node->getEdges().size();
        for(int i=0;i<edgesSize;++i) {
            auto& edge = node->getEdges().at(i);
            auto castedEdge = static_pointer_cast<NetworkEdge>(edge);
            //network should be wellformed, so that the weak_ptr is not empty at this point, otherwise the further behavior is undefined
            auto targetNode = edge->getTarget().lock();
            auto& correspondingTargetNode = nodes[targetNode->getId()];
            if(!correspondingTargetNode) {
                correspondingTargetNode = make_shared<Node>(targetNode->getId());
            }
            //add corresponding residual edge if the capacity is not maxed out by the flow
            if(castedEdge->getFlow() < castedEdge->getCapacity())  {
                //the corresponding edge does not have a trace (trace can be accessed over the reference edge pointer)
                auto correspondingEdge = make_shared<NetworkEdge>(vector<int>(),correspondingNode,correspondingTargetNode,
                        castedEdge->getCapacity() - castedEdge->getFlow(),castedEdge->getCost());
                correspondingNode->addEdge(correspondingEdge);
                correspondingTargetNode->addInEdge(correspondingEdge);
                //corresponding edges are linked to original network forward edge
                correspondingEdge->setReferenceEdge(castedEdge);
            }
            //add reverse edges to the residual network
            if(castedEdge->getFlow() > 0) {
                //the corresponding reverse edge does not have a trace (trace can be accessed over the reference edge pointer)
                auto reverseEdge = make_shared<NetworkEdge>(vector<int>(),nodes[targetNode->getId()],
                        nodes[node->getId()],castedEdge->getFlow(),castedEdge->getCost() * -1);
                nodes[targetNode->getId()]->addEdge(reverseEdge);
                nodes[node->getId()]->addInEdge(reverseEdge);
                reverseEdge->setIsReverse(true);
                //reverse edges are linked from residual to original network forward edge
                reverseEdge->setReferenceEdge(castedEdge);
            }
        }
    }
}

void Network::calculateMinimumCostMaximumFlow() {

    auto shortestPath = residualNetwork->shortestPathByBellmanFord(residualNetwork->nodes[sourceNodeId],residualNetwork->nodes[sinkNodeId]);
    while(!shortestPath->empty()) {
        //find the minimal absolute value by which the flow can be altered along the path
        int minFlow = static_pointer_cast<NetworkEdge>(shortestPath->at(0))->getCapacity();
        for(int i=1;i<shortestPath->size();++i) {
            auto& edge = shortestPath->at(i);
            auto castedEdge = static_pointer_cast<NetworkEdge>(edge);
            minFlow = (minFlow == 0 || castedEdge->getCapacity() < minFlow)?castedEdge->getCapacity():minFlow;
        }
        //minflow should be greater zero at this point

        //augment the current flow und update the residual network accordingly
        for(auto& edge:*shortestPath) {
            auto castedEdge = static_pointer_cast<NetworkEdge>(edge);
            auto referenceEdge = castedEdge->getReferenceEdge().lock();
            int oldFlow = referenceEdge->getFlow(),
                    capacity = referenceEdge->getCapacity();
            if(castedEdge->getIsReverse()) {
                //decrease flow of forward arc
                referenceEdge->setFlow(oldFlow - minFlow);
                //check if the forward edge has to be added again
                if(capacity == oldFlow) {
                    auto& node = residualNetwork->nodes[castedEdge->getTarget().lock()->getId()];
                    auto& targetNode = residualNetwork->nodes[castedEdge->getSource().lock()->getId()];
                    auto newForwardEdge = make_shared<NetworkEdge>(vector<int>(),node,
                            castedEdge->getSource(),minFlow,castedEdge->getCost()*(-1));
                    node->addEdge(newForwardEdge);
                    targetNode->addInEdge(newForwardEdge);
                }
                //check if the reverse edge has to be deleted
                if(referenceEdge->getFlow() == 0) {
                    auto& node = residualNetwork->nodes[castedEdge->getSource().lock()->getId()];
                    auto it = find(node->getEdges().begin(),node->getEdges().end(),castedEdge);
                    node->getEdges().erase(it);
                }
            } else {
                //increase flow of forward arc
                referenceEdge->setFlow(oldFlow + minFlow);
                //check if the reverse edge has to be added again
                if(oldFlow == 0) {
                    auto& node = residualNetwork->nodes[castedEdge->getTarget().lock()->getId()];
                    auto& targetNode = residualNetwork->nodes[castedEdge->getSource().lock()->getId()];
                    auto newReverseEdge = make_shared<NetworkEdge>(vector<int>(),node,
                                                                   castedEdge->getSource(),minFlow,castedEdge->getCost()*(-1));
                    node->addEdge(newReverseEdge);
                    targetNode->addInEdge(newReverseEdge);
                    newReverseEdge->setIsReverse(true);
                }
                //check if the forward edge has to be deleted
                if(referenceEdge->getFlow() == capacity) {
                    auto& node = residualNetwork->nodes[castedEdge->getSource().lock()->getId()];
                    auto it = find(node->getEdges().begin(),node->getEdges().end(),castedEdge);
                    node->getEdges().erase(it);
                }
            }
        }
        shortestPath = residualNetwork->shortestPathByBellmanFord(residualNetwork->nodes[sourceNodeId],residualNetwork->nodes[sinkNodeId]);
    }
}

ostream & operator<<(ostream & out, const Network & network) {
    out << "digraph g {" << endl << endl;

    out << "node [shape = ellipse]" << endl;

    for(auto& node:network.nodes) {
        out << node->getId() << "[label=\"" << node->getId() << "\"];" <<  endl;
    }

    for(auto& node:network.nodes) {
        for(auto& edge:node->getEdges()) {
            auto targetNode = edge->getTarget();
            auto castedEdge = static_pointer_cast<NetworkEdge>(edge);
            int capacity = castedEdge->getCapacity(),
                flow = castedEdge->getFlow();

            string traceString = "";
            for(int input:edge->getTrace()) {
                traceString += to_string(input) + ".";
            }
            traceString = traceString.substr(0,traceString.length()-1);

            out << node->getId() << " -> " << targetNode.lock()->getId() << "[label=\"" << traceString << ",(" << to_string(flow) << "," << to_string(capacity) << ")\"];"
                << "  //" << node->getId() << " -> " << targetNode.lock()->getId() << endl;
        }
    }

    out << endl << "}" << endl;
    return out;
}

void Network::toDot(const string &fname) {
    ofstream out(fname + ".dot");
    out << *this;
    out.close();
}


