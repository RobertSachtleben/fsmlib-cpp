/*
 * Copyright. GaÃ«l Dottel, Christoph Hilken, and Jan Peleska 2016 - 2021
 *
 * Licensed under the EUPL V.1.1
 */
#include "Network.h"
#include "graphs/NetworkEdge.h"

#include <fstream>
#include <iostream>
#include <algorithm>

Network::Network(const vector<shared_ptr<Node>> &nodes,int sourceNodeId, int sinkNodeId)
    : Graph(nodes),sourceNodeId(sourceNodeId),sinkNodeId(sinkNodeId)
{
    residualNetwork = make_shared<Network>(this);
}


Network::Network(Network *network)
    : Graph(vector<shared_ptr<Node>>(network->nodes.size(),nullptr)),sourceNodeId(network->sourceNodeId),
        sinkNodeId(network->sinkNodeId),residualNetwork(shared_ptr<Network>())
{
    /**
     * It is assumed that network itself does not contain any reverse edges and is an actual network and no residual,
     * otherwise the network generated by this constructor, is anything else than a residual network for 'network'.
     */

    for(auto& node:network->nodes) {
        auto& correspondingNode = nodes[node->getId()];
        if(!correspondingNode) {
            correspondingNode = make_shared<Node>(node->getId());
        }
        int edgesSize = node->getEdges().size();
        for(int i=0;i<edgesSize;++i) {
            auto& edge = node->getEdges().at(i);
            auto castedEdge = static_pointer_cast<NetworkEdge>(edge);
            //network should be wellformed, so that the weak_ptr is not empty at this point, otherwise the further behavior is undefined
            auto targetNode = edge->getTarget().lock();
            auto& correspondingTargetNode = nodes[targetNode->getId()];
            if(!correspondingTargetNode) {
                correspondingTargetNode = make_shared<Node>(targetNode->getId());
            }
            int flow = castedEdge->getFlow(),
                capacity = castedEdge->getCapacity();
            //add corresponding residual edge if the capacity is not maxed out by the flow
            if(capacity< 0 || flow < capacity)  {
                //the corresponding edge does not have a trace (trace can be accessed over the reference edge pointer)
                auto correspondingEdge = make_shared<NetworkEdge>(vector<int>(),correspondingNode,correspondingTargetNode,
                                                                  (capacity<0)?-1:capacity-flow,castedEdge->getCost());
                correspondingNode->addEdge(correspondingEdge);
                correspondingTargetNode->addInEdge(correspondingEdge);
                //corresponding edges are linked to original network forward edge
                correspondingEdge->setReferenceEdge(castedEdge);
            }
            //add reverse edges to the residual network
            if(flow > 0) {
                //the corresponding reverse edge does not have a trace (trace can be accessed over the reference edge pointer)
                auto reverseEdge = make_shared<NetworkEdge>(vector<int>(),nodes[targetNode->getId()],
                        nodes[node->getId()],flow,castedEdge->getCost() * -1);
                nodes[targetNode->getId()]->addEdge(reverseEdge);
                nodes[node->getId()]->addInEdge(reverseEdge);
                reverseEdge->setIsReverse(true);
                //reverse edges are linked from residual to original network forward edge
                reverseEdge->setReferenceEdge(castedEdge);
            }
        }
    }
}

void Network::calculateMinimumCostMaximumFlow() {

    auto shortestPath = residualNetwork->shortestPathByBellmanFord(residualNetwork->nodes[sourceNodeId],residualNetwork->nodes[sinkNodeId]);
    while(shortestPath && !shortestPath->empty()) {
        //find the minimal absolute value by which the flow can be altered along the path
        int minFlow = static_pointer_cast<NetworkEdge>(shortestPath->at(0))->getCapacity();
        for(int i=1;i<shortestPath->size();++i) {
            auto& edge = shortestPath->at(i);
            auto castedEdge = static_pointer_cast<NetworkEdge>(edge);
            int capacity = castedEdge->getCapacity();
            minFlow = (capacity > 0 && (capacity < minFlow || minFlow < 0) )?capacity:minFlow;
        }
        //minflow should be greater zero at this point
        if(minFlow < 0) { // this should not happen. if thats the case all edges on the path have infinite capacity
            /**
             * this means that the source node does have infinite capacity edges, that can not be maxed out (logically), so
             * there is no max flow in this graph anyways, and thus no solution to the min cost/max flow problem
             **/
            return;
        } else if(minFlow == 0){ // should not happen either
            return;
        }
        //augment the current flow und update the residual network accordingly
        for(auto& edge:*shortestPath) {
            auto castedEdge = static_pointer_cast<NetworkEdge>(edge);
            auto referenceEdge = castedEdge->getReferenceEdge().lock();
            int oldFlow = referenceEdge->getFlow(),
                    capacity = referenceEdge->getCapacity();
            if(castedEdge->getIsReverse()) {
                //decrease flow of forward arc
                referenceEdge->setFlow(oldFlow - minFlow);
                //check if the forward edge has to be added again
                if(capacity > 0 && capacity == oldFlow) {
                    auto& node = residualNetwork->nodes[castedEdge->getTarget().lock()->getId()];
                    auto& targetNode = residualNetwork->nodes[castedEdge->getSource().lock()->getId()];
                    auto newForwardEdge = make_shared<NetworkEdge>(vector<int>(),node,
                            targetNode,minFlow,castedEdge->getCost()*(-1));
                    node->addEdge(newForwardEdge);
                    targetNode->addInEdge(newForwardEdge);
                    newForwardEdge->setReferenceEdge(referenceEdge);
                } else if(capacity < oldFlow) {
                    //update the capacity of the forward edge
                    //find the forward edge
                    auto& node = residualNetwork->nodes[castedEdge->getTarget().lock()->getId()];
                    shared_ptr<NetworkEdge> forwardEdge;
                    for(auto& e:node->getEdges()) {
                        auto ce = static_pointer_cast<NetworkEdge>(e);
                        if(!ce->getIsReverse() && ce->getReferenceEdge().lock() == referenceEdge)
                            forwardEdge = ce;
                    }
                    forwardEdge->setCapacity(capacity-oldFlow+minFlow);
                }
                //check if the reverse edge has to be deleted
                if(referenceEdge->getFlow() == 0) {
                    auto& node = residualNetwork->nodes[castedEdge->getSource().lock()->getId()];
                    auto& edges = node->getEdges();
                    edges.erase(remove(edges.begin(),edges.end(),castedEdge),edges.end());

                    auto& targetNode = residualNetwork->nodes[castedEdge->getTarget().lock()->getId()];
                    auto& tgtInEdges = targetNode->getInEdges();
                    tgtInEdges.erase(remove_if(tgtInEdges.begin(),tgtInEdges.end(),[castedEdge](weak_ptr<Edge> wp){
                        auto sp = wp.lock();
                        if(sp)
                            return castedEdge == sp;
                        return false;
                    }),tgtInEdges.end());
                } else if(referenceEdge->getFlow() > 0) {
                    //update the capacity of the reverse edge
                    castedEdge->setCapacity(referenceEdge->getFlow());
                }
            } else {
                //increase flow of forward arc
                referenceEdge->setFlow(oldFlow + minFlow);
                //check if the reverse edge has to be added again
                if(oldFlow == 0) {
                    auto& node = residualNetwork->nodes[castedEdge->getTarget().lock()->getId()];
                    auto& targetNode = residualNetwork->nodes[castedEdge->getSource().lock()->getId()];
                    auto newReverseEdge = make_shared<NetworkEdge>(vector<int>(),node,
                                                                   castedEdge->getSource(),minFlow,castedEdge->getCost()*(-1));
                    node->addEdge(newReverseEdge);
                    targetNode->addInEdge(newReverseEdge);
                    newReverseEdge->setIsReverse(true);
                    newReverseEdge->setReferenceEdge(referenceEdge);
                } else if(oldFlow > 0) {
                    //update the capacity of the reverse edge
                    //find the reverse edge
                    auto& node = residualNetwork->nodes[castedEdge->getTarget().lock()->getId()];
                    shared_ptr<NetworkEdge> reverseEdge;
                    for(auto& e:node->getEdges()) {
                        auto ce = static_pointer_cast<NetworkEdge>(e);
                        if(ce->getIsReverse() && ce->getReferenceEdge().lock() == referenceEdge)
                            reverseEdge = ce;
                    }
                    reverseEdge->setCapacity(oldFlow+minFlow);
                }
                //check if the forward edge has to be deleted
                if(capacity > 0 && referenceEdge->getFlow() == capacity) {
                    auto& node = residualNetwork->nodes[castedEdge->getSource().lock()->getId()];
                    auto& edges = node->getEdges();
                    edges.erase(remove(edges.begin(),edges.end(),castedEdge),edges.end());

                    auto& targetNode = residualNetwork->nodes[castedEdge->getTarget().lock()->getId()];
                    auto& tgtInEdges = targetNode->getInEdges();
                    tgtInEdges.erase(remove_if(tgtInEdges.begin(),tgtInEdges.end(),[castedEdge](weak_ptr<Edge> wp){
                        auto sp = wp.lock();
                        if(sp)
                            return castedEdge == sp;
                        return false;
                    }),tgtInEdges.end());
                } else if(referenceEdge->getFlow() < capacity) {
                    //update the capacity of the forward edge
                    castedEdge->setCapacity(capacity - referenceEdge->getFlow());
                }
            }
        }
        shortestPath = residualNetwork->shortestPathByBellmanFord(residualNetwork->nodes[sourceNodeId],residualNetwork->nodes[sinkNodeId]);
    }
}

ostream & operator<<(ostream & out, const Network & network) {
    out << "digraph g {" << endl << endl;

    out << "node [shape = ellipse]" << endl;

    for(auto& node:network.nodes) {
        out << node->getId() << "[label=\"" << node->getId() << "\"];" <<  endl;
    }

    for(auto& node:network.nodes) {
        for(auto& edge:node->getEdges()) {
            auto targetNode = edge->getTarget();
            auto castedEdge = static_pointer_cast<NetworkEdge>(edge);
            int capacity = castedEdge->getCapacity(),
                flow = castedEdge->getFlow();

            string traceString = "";
            for(int input:edge->getTrace()) {
                traceString += to_string(input) + ".";
            }
            traceString = traceString.substr(0,traceString.length()-1);

            out << node->getId() << " -> " << targetNode.lock()->getId() << "[label=\"" << traceString << ",(" << to_string(flow) << "," << to_string(capacity) << ")\"];"
                << "  //" << node->getId() << " -> " << targetNode.lock()->getId() << endl;
        }
    }

    out << endl << "}" << endl;
    return out;
}

void Network::toDot(const string &fname) {
    ofstream out(fname + ".dot");
    out << *this;
    out.close();
}


